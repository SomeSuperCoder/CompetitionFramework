package internal

import (
	"context"
	"fmt"
	"log"

	"github.com/SomeSuperCoder/CompetitionFramework/backend/repository"
)

func BackgroundMatchMakingStep(ctx context.Context, repo *repository.Queries) error {
	// Check for pending competitions and start them
	competitions, err := repo.FindAllCompetitionsToStart(ctx)
	if err != nil {
		return fmt.Errorf("Failed to find comepetitions to start due to: %w", err)
	}
	for _, competition := range competitions {
		log.Printf("Starting competition %v", competition.Name)
		repo.SetCompetitionStatus(ctx, repository.SetCompetitionStatusParams{
			ID:     competition.ID,
			Status: repository.UnitStatusRunning,
		})
	}

	// TODO: Check the start channel

	// Check for currently running competitions
	competitions, err = repo.FindAllRunningCompetitions(ctx)
	for _, competition := range competitions {
		matches, err := repo.FindAllRunningMatchesInCompetition(ctx, repository.FindAllRunningMatchesInCompetitionParams{
			Competition: competition.ID,
		})
	}

	// Check if all matches are finished

	// Check current match amount and end the competition if required

	// Generate a new match set if needed

	// Check for currently running matches

	// Check if all rounds in them are finished

	// Check if min_rounds is satisfied or if a tie break is required

	// Spawn a new round if needed

	// Or... Set the winner and finish the match
}
